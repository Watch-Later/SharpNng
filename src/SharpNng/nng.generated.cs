//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

using System.Runtime.InteropServices;

[System.Security.SuppressUnmanagedCodeSecurity]
public static partial class nng
{
    public enum nng_sockaddr_family : int
    {
        NNG_AF_UNSPEC = unchecked((int)0),
        
        NNG_AF_INPROC = unchecked((int)1),
        
        NNG_AF_IPC = unchecked((int)2),
        
        NNG_AF_INET = unchecked((int)3),
        
        NNG_AF_INET6 = unchecked((int)4),
        
        /// <summary>
        /// ZeroTier
        /// </summary>
        NNG_AF_ZT = unchecked((int)5),
        
        NNG_AF_ABSTRACT = unchecked((int)6),
    }
    
    public const nng.nng_sockaddr_family NNG_AF_UNSPEC = nng_sockaddr_family.NNG_AF_UNSPEC;
    
    public const nng.nng_sockaddr_family NNG_AF_INPROC = nng_sockaddr_family.NNG_AF_INPROC;
    
    public const nng.nng_sockaddr_family NNG_AF_IPC = nng_sockaddr_family.NNG_AF_IPC;
    
    public const nng.nng_sockaddr_family NNG_AF_INET = nng_sockaddr_family.NNG_AF_INET;
    
    public const nng.nng_sockaddr_family NNG_AF_INET6 = nng_sockaddr_family.NNG_AF_INET6;
    
    /// <summary>
    /// ZeroTier
    /// </summary>
    public const nng.nng_sockaddr_family NNG_AF_ZT = nng_sockaddr_family.NNG_AF_ZT;
    
    public const nng.nng_sockaddr_family NNG_AF_ABSTRACT = nng_sockaddr_family.NNG_AF_ABSTRACT;
    
    /// <summary>
    /// Arguably the pipe callback functions could be handled as an option,
    /// but with the need to specify an argument, we find it best to unify
    /// this as a separate function to pass in the argument and the callback.
    /// Only one callback can be set on a given socket, and there is no way
    /// to retrieve the old value.
    /// </summary>
    public enum nng_pipe_ev : int
    {
        /// <summary>
        /// Called just before pipe added to socket
        /// </summary>
        NNG_PIPE_EV_ADD_PRE,
        
        /// <summary>
        /// Called just after pipe added to socket
        /// </summary>
        NNG_PIPE_EV_ADD_POST,
        
        /// <summary>
        /// Called just after pipe removed from socket
        /// </summary>
        NNG_PIPE_EV_REM_POST,
        
        /// <summary>
        /// Used internally, must be last.
        /// </summary>
        NNG_PIPE_EV_NUM,
    }
    
    /// <summary>
    /// Called just before pipe added to socket
    /// </summary>
    public const nng.nng_pipe_ev NNG_PIPE_EV_ADD_PRE = nng_pipe_ev.NNG_PIPE_EV_ADD_PRE;
    
    /// <summary>
    /// Called just after pipe added to socket
    /// </summary>
    public const nng.nng_pipe_ev NNG_PIPE_EV_ADD_POST = nng_pipe_ev.NNG_PIPE_EV_ADD_POST;
    
    /// <summary>
    /// Called just after pipe removed from socket
    /// </summary>
    public const nng.nng_pipe_ev NNG_PIPE_EV_REM_POST = nng_pipe_ev.NNG_PIPE_EV_REM_POST;
    
    /// <summary>
    /// Used internally, must be last.
    /// </summary>
    public const nng.nng_pipe_ev NNG_PIPE_EV_NUM = nng_pipe_ev.NNG_PIPE_EV_NUM;
    
    public enum nng_stat_type_enum : int
    {
        /// <summary>
        /// Stat is for scoping, and carries no value
        /// </summary>
        NNG_STAT_SCOPE = unchecked((int)0),
        
        /// <summary>
        /// Numeric "absolute" value, diffs meaningless
        /// </summary>
        NNG_STAT_LEVEL = unchecked((int)1),
        
        /// <summary>
        /// Incrementing value (diffs are meaningful)
        /// </summary>
        NNG_STAT_COUNTER = unchecked((int)2),
        
        /// <summary>
        /// Value is a string
        /// </summary>
        NNG_STAT_STRING = unchecked((int)3),
        
        /// <summary>
        /// Value is a boolean
        /// </summary>
        NNG_STAT_BOOLEAN = unchecked((int)4),
        
        /// <summary>
        /// Value is a numeric ID
        /// </summary>
        NNG_STAT_ID = unchecked((int)5),
    }
    
    /// <summary>
    /// Stat is for scoping, and carries no value
    /// </summary>
    public const nng.nng_stat_type_enum NNG_STAT_SCOPE = nng_stat_type_enum.NNG_STAT_SCOPE;
    
    /// <summary>
    /// Numeric "absolute" value, diffs meaningless
    /// </summary>
    public const nng.nng_stat_type_enum NNG_STAT_LEVEL = nng_stat_type_enum.NNG_STAT_LEVEL;
    
    /// <summary>
    /// Incrementing value (diffs are meaningful)
    /// </summary>
    public const nng.nng_stat_type_enum NNG_STAT_COUNTER = nng_stat_type_enum.NNG_STAT_COUNTER;
    
    /// <summary>
    /// Value is a string
    /// </summary>
    public const nng.nng_stat_type_enum NNG_STAT_STRING = nng_stat_type_enum.NNG_STAT_STRING;
    
    /// <summary>
    /// Value is a boolean
    /// </summary>
    public const nng.nng_stat_type_enum NNG_STAT_BOOLEAN = nng_stat_type_enum.NNG_STAT_BOOLEAN;
    
    /// <summary>
    /// Value is a numeric ID
    /// </summary>
    public const nng.nng_stat_type_enum NNG_STAT_ID = nng_stat_type_enum.NNG_STAT_ID;
    
    public enum nng_unit_enum : int
    {
        /// <summary>
        /// No special units
        /// </summary>
        NNG_UNIT_NONE = unchecked((int)0),
        
        /// <summary>
        /// Bytes, e.g. bytes sent, etc.
        /// </summary>
        NNG_UNIT_BYTES = unchecked((int)1),
        
        /// <summary>
        /// Messages, one per message
        /// </summary>
        NNG_UNIT_MESSAGES = unchecked((int)2),
        
        /// <summary>
        /// Milliseconds
        /// </summary>
        NNG_UNIT_MILLIS = unchecked((int)3),
        
        /// <summary>
        /// Some other type of event
        /// </summary>
        NNG_UNIT_EVENTS = unchecked((int)4),
    }
    
    /// <summary>
    /// No special units
    /// </summary>
    public const nng.nng_unit_enum NNG_UNIT_NONE = nng_unit_enum.NNG_UNIT_NONE;
    
    /// <summary>
    /// Bytes, e.g. bytes sent, etc.
    /// </summary>
    public const nng.nng_unit_enum NNG_UNIT_BYTES = nng_unit_enum.NNG_UNIT_BYTES;
    
    /// <summary>
    /// Messages, one per message
    /// </summary>
    public const nng.nng_unit_enum NNG_UNIT_MESSAGES = nng_unit_enum.NNG_UNIT_MESSAGES;
    
    /// <summary>
    /// Milliseconds
    /// </summary>
    public const nng.nng_unit_enum NNG_UNIT_MILLIS = nng_unit_enum.NNG_UNIT_MILLIS;
    
    /// <summary>
    /// Some other type of event
    /// </summary>
    public const nng.nng_unit_enum NNG_UNIT_EVENTS = nng_unit_enum.NNG_UNIT_EVENTS;
    
    /// <summary>
    /// Error codes.  These generally have different values from UNIX errnos,
    /// so take care about converting them.  The one exception is that 0 is
    /// unambiguously "success".
    /// </summary>
    /// <remarks>
    /// NNG_SYSERR is a special code, which allows us to wrap errors from the
    /// underlying operating system.  We generally prefer to map errors to one
    /// of the above, but if we cannot, then we just encode an error this way.
    /// The bit is large enough to accommodate all known UNIX and Win32 error
    /// codes.  We try hard to match things semantically to one of our standard
    /// errors.  For example, a connection reset or aborted we treat as a
    /// closed connection, because that's basically what it means.  (The remote
    /// peer closed the connection.)  For certain kinds of resource exhaustion
    /// we treat it the same as memory.  But for files, etc. that's OS-specific,
    /// and we use the generic below.  Some of the above error codes we use
    /// internally, and the application should never see (e.g. NNG_EINTR).NNG_ETRANERR is like ESYSERR, but is used to wrap transport specific
    /// errors, from different transports.  It should only be used when none
    /// of the other options are available.
    /// </remarks>
    public enum nng_errno_enum : int
    {
        NNG_EINTR = unchecked((int)1),
        
        NNG_ENOMEM = unchecked((int)2),
        
        NNG_EINVAL = unchecked((int)3),
        
        NNG_EBUSY = unchecked((int)4),
        
        NNG_ETIMEDOUT = unchecked((int)5),
        
        NNG_ECONNREFUSED = unchecked((int)6),
        
        NNG_ECLOSED = unchecked((int)7),
        
        NNG_EAGAIN = unchecked((int)8),
        
        NNG_ENOTSUP = unchecked((int)9),
        
        NNG_EADDRINUSE = unchecked((int)10),
        
        NNG_ESTATE = unchecked((int)11),
        
        NNG_ENOENT = unchecked((int)12),
        
        NNG_EPROTO = unchecked((int)13),
        
        NNG_EUNREACHABLE = unchecked((int)14),
        
        NNG_EADDRINVAL = unchecked((int)15),
        
        NNG_EPERM = unchecked((int)16),
        
        NNG_EMSGSIZE = unchecked((int)17),
        
        NNG_ECONNABORTED = unchecked((int)18),
        
        NNG_ECONNRESET = unchecked((int)19),
        
        NNG_ECANCELED = unchecked((int)20),
        
        NNG_ENOFILES = unchecked((int)21),
        
        NNG_ENOSPC = unchecked((int)22),
        
        NNG_EEXIST = unchecked((int)23),
        
        NNG_EREADONLY = unchecked((int)24),
        
        NNG_EWRITEONLY = unchecked((int)25),
        
        NNG_ECRYPTO = unchecked((int)26),
        
        NNG_EPEERAUTH = unchecked((int)27),
        
        NNG_ENOARG = unchecked((int)28),
        
        NNG_EAMBIGUOUS = unchecked((int)29),
        
        NNG_EBADTYPE = unchecked((int)30),
        
        NNG_ECONNSHUT = unchecked((int)31),
        
        NNG_EINTERNAL = unchecked((int)1000),
        
        NNG_ESYSERR = unchecked((int)0x10000000),
        
        NNG_ETRANERR = unchecked((int)0x20000000),
    }
    
    public const nng.nng_errno_enum NNG_EINTR = nng_errno_enum.NNG_EINTR;
    
    public const nng.nng_errno_enum NNG_ENOMEM = nng_errno_enum.NNG_ENOMEM;
    
    public const nng.nng_errno_enum NNG_EINVAL = nng_errno_enum.NNG_EINVAL;
    
    public const nng.nng_errno_enum NNG_EBUSY = nng_errno_enum.NNG_EBUSY;
    
    public const nng.nng_errno_enum NNG_ETIMEDOUT = nng_errno_enum.NNG_ETIMEDOUT;
    
    public const nng.nng_errno_enum NNG_ECONNREFUSED = nng_errno_enum.NNG_ECONNREFUSED;
    
    public const nng.nng_errno_enum NNG_ECLOSED = nng_errno_enum.NNG_ECLOSED;
    
    public const nng.nng_errno_enum NNG_EAGAIN = nng_errno_enum.NNG_EAGAIN;
    
    public const nng.nng_errno_enum NNG_ENOTSUP = nng_errno_enum.NNG_ENOTSUP;
    
    public const nng.nng_errno_enum NNG_EADDRINUSE = nng_errno_enum.NNG_EADDRINUSE;
    
    public const nng.nng_errno_enum NNG_ESTATE = nng_errno_enum.NNG_ESTATE;
    
    public const nng.nng_errno_enum NNG_ENOENT = nng_errno_enum.NNG_ENOENT;
    
    public const nng.nng_errno_enum NNG_EPROTO = nng_errno_enum.NNG_EPROTO;
    
    public const nng.nng_errno_enum NNG_EUNREACHABLE = nng_errno_enum.NNG_EUNREACHABLE;
    
    public const nng.nng_errno_enum NNG_EADDRINVAL = nng_errno_enum.NNG_EADDRINVAL;
    
    public const nng.nng_errno_enum NNG_EPERM = nng_errno_enum.NNG_EPERM;
    
    public const nng.nng_errno_enum NNG_EMSGSIZE = nng_errno_enum.NNG_EMSGSIZE;
    
    public const nng.nng_errno_enum NNG_ECONNABORTED = nng_errno_enum.NNG_ECONNABORTED;
    
    public const nng.nng_errno_enum NNG_ECONNRESET = nng_errno_enum.NNG_ECONNRESET;
    
    public const nng.nng_errno_enum NNG_ECANCELED = nng_errno_enum.NNG_ECANCELED;
    
    public const nng.nng_errno_enum NNG_ENOFILES = nng_errno_enum.NNG_ENOFILES;
    
    public const nng.nng_errno_enum NNG_ENOSPC = nng_errno_enum.NNG_ENOSPC;
    
    public const nng.nng_errno_enum NNG_EEXIST = nng_errno_enum.NNG_EEXIST;
    
    public const nng.nng_errno_enum NNG_EREADONLY = nng_errno_enum.NNG_EREADONLY;
    
    public const nng.nng_errno_enum NNG_EWRITEONLY = nng_errno_enum.NNG_EWRITEONLY;
    
    public const nng.nng_errno_enum NNG_ECRYPTO = nng_errno_enum.NNG_ECRYPTO;
    
    public const nng.nng_errno_enum NNG_EPEERAUTH = nng_errno_enum.NNG_EPEERAUTH;
    
    public const nng.nng_errno_enum NNG_ENOARG = nng_errno_enum.NNG_ENOARG;
    
    public const nng.nng_errno_enum NNG_EAMBIGUOUS = nng_errno_enum.NNG_EAMBIGUOUS;
    
    public const nng.nng_errno_enum NNG_EBADTYPE = nng_errno_enum.NNG_EBADTYPE;
    
    public const nng.nng_errno_enum NNG_ECONNSHUT = nng_errno_enum.NNG_ECONNSHUT;
    
    public const nng.nng_errno_enum NNG_EINTERNAL = nng_errno_enum.NNG_EINTERNAL;
    
    public const nng.nng_errno_enum NNG_ESYSERR = nng_errno_enum.NNG_ESYSERR;
    
    public const nng.nng_errno_enum NNG_ETRANERR = nng_errno_enum.NNG_ETRANERR;
    
    /// <summary>
    /// Network status values.
    /// These values are supplied to help folks checking status.  They are the
    /// return values from zt_opt_status.  We avoid hard coding them as defines,
    /// to keep applications from baking in values that may change if the
    /// underlying ZeroTier transport changes.
    /// </summary>
    public enum nng_zt_status : int
    {
        NNG_ZT_STATUS_UP,
        
        NNG_ZT_STATUS_CONFIG,
        
        NNG_ZT_STATUS_DENIED,
        
        NNG_ZT_STATUS_NOTFOUND,
        
        NNG_ZT_STATUS_ERROR,
        
        NNG_ZT_STATUS_OBSOLETE,
        
        NNG_ZT_STATUS_UNKNOWN,
    }
    
    public const nng.nng_zt_status NNG_ZT_STATUS_UP = nng_zt_status.NNG_ZT_STATUS_UP;
    
    public const nng.nng_zt_status NNG_ZT_STATUS_CONFIG = nng_zt_status.NNG_ZT_STATUS_CONFIG;
    
    public const nng.nng_zt_status NNG_ZT_STATUS_DENIED = nng_zt_status.NNG_ZT_STATUS_DENIED;
    
    public const nng.nng_zt_status NNG_ZT_STATUS_NOTFOUND = nng_zt_status.NNG_ZT_STATUS_NOTFOUND;
    
    public const nng.nng_zt_status NNG_ZT_STATUS_ERROR = nng_zt_status.NNG_ZT_STATUS_ERROR;
    
    public const nng.nng_zt_status NNG_ZT_STATUS_OBSOLETE = nng_zt_status.NNG_ZT_STATUS_OBSOLETE;
    
    public const nng.nng_zt_status NNG_ZT_STATUS_UNKNOWN = nng_zt_status.NNG_ZT_STATUS_UNKNOWN;
    
    /// <summary>
    /// Identifiers are wrapped in a structure to improve compiler validation
    /// of incorrect passing.  This gives us strong type checking.  Modern
    /// compilers compile passing these by value to identical code as passing
    /// the integer type (at least with optimization applied).  Please do not
    /// access the ID member directly.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial record struct nng_ctx_s
    {
        public uint id;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial record struct nng_dialer_s
    {
        public uint id;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial record struct nng_listener_s
    {
        public uint id;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial record struct nng_pipe_s
    {
        public uint id;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial record struct nng_socket_s
    {
        public uint id;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_msg : IEquatable<nng_msg>
    {
        private readonly IntPtr _handle;
        
        public nng_msg(IntPtr handle) => _handle = handle;
        
        public IntPtr Handle => _handle;
        
        public bool Equals(nng_msg other) => _handle.Equals(other._handle);
        
        public override bool Equals(object obj) => obj is nng_msg other && Equals(other);
        
        public override int GetHashCode() => _handle.GetHashCode();
        
        public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
        
        public static bool operator ==(nng_msg left, nng_msg right) => left.Equals(right);
        
        public static bool operator !=(nng_msg left, nng_msg right) => !left.Equals(right);
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_stat : IEquatable<nng_stat>
    {
        private readonly IntPtr _handle;
        
        public nng_stat(IntPtr handle) => _handle = handle;
        
        public IntPtr Handle => _handle;
        
        public bool Equals(nng_stat other) => _handle.Equals(other._handle);
        
        public override bool Equals(object obj) => obj is nng_stat other && Equals(other);
        
        public override int GetHashCode() => _handle.GetHashCode();
        
        public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
        
        public static bool operator ==(nng_stat left, nng_stat right) => left.Equals(right);
        
        public static bool operator !=(nng_stat left, nng_stat right) => !left.Equals(right);
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_aio : IEquatable<nng_aio>
    {
        private readonly IntPtr _handle;
        
        public nng_aio(IntPtr handle) => _handle = handle;
        
        public IntPtr Handle => _handle;
        
        public bool Equals(nng_aio other) => _handle.Equals(other._handle);
        
        public override bool Equals(object obj) => obj is nng_aio other && Equals(other);
        
        public override int GetHashCode() => _handle.GetHashCode();
        
        public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
        
        public static bool operator ==(nng_aio left, nng_aio right) => left.Equals(right);
        
        public static bool operator !=(nng_aio left, nng_aio right) => !left.Equals(right);
    }
    
    /// <summary>
    /// Some address details. This is in some ways like a traditional sockets
    /// sockaddr, but we have our own to cope with our unique families, etc.
    /// The details of this structure are directly exposed to applications.
    /// These structures can be obtained via property lookups, etc.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial struct nng_sockaddr_inproc
    {
        public ushort sa_family;
        
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
        public string sa_name;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial struct nng_sockaddr_path
    {
        public ushort sa_family;
        
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
        public string sa_path;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public unsafe partial struct nng_sockaddr_in6
    {
        public ushort sa_family;
        
        public ushort sa_port;
        
        public fixed byte sa_addr[16];
        
        public uint sa_scope;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial struct nng_sockaddr_in
    {
        public ushort sa_family;
        
        public ushort sa_port;
        
        public uint sa_addr;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial struct nng_sockaddr_zt
    {
        public ushort sa_family;
        
        public ulong sa_nwid;
        
        public ulong sa_nodeid;
        
        public uint sa_port;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public unsafe partial struct nng_sockaddr_abstract
    {
        public ushort sa_family;
        
        /// <summary>
        /// will be 0 - 107 max.
        /// </summary>
        public ushort sa_len;
        
        /// <summary>
        /// 108 linux/windows, without leading NUL
        /// </summary>
        public fixed byte sa_name[107];
    }
    
    /// <summary>
    /// nng_sockaddr_storage is the the size required to store any nng_sockaddr.
    /// This size must not change, and no individual nng_sockaddr type may grow
    /// larger than this without breaking binary compatibility.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public unsafe partial struct nng_sockaddr_storage
    {
        public ushort sa_family;
        
        public fixed ulong sa_pad[16];
    }
    
    [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
    public partial struct nng_sockaddr
    {
        [FieldOffset(0)]
        public ushort s_family;
        
        [FieldOffset(0)]
        public nng.nng_sockaddr_ipc s_ipc;
        
        [FieldOffset(0)]
        public nng.nng_sockaddr_inproc s_inproc;
        
        [FieldOffset(0)]
        public nng.nng_sockaddr_in6 s_in6;
        
        [FieldOffset(0)]
        public nng.nng_sockaddr_in s_in;
        
        [FieldOffset(0)]
        public nng.nng_sockaddr_zt s_zt;
        
        [FieldOffset(0)]
        public nng.nng_sockaddr_abstract s_abstract;
        
        [FieldOffset(0)]
        public nng.nng_sockaddr_storage s_storage;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_sockaddr_ipc : IEquatable<nng_sockaddr_ipc>
    {
        public nng_sockaddr_ipc(nng.nng_sockaddr_path value) => this.Value = value;
        
        public readonly nng.nng_sockaddr_path Value;
        
        public bool Equals(nng_sockaddr_ipc other) =>  Value.Equals(other.Value);
        
        public override bool Equals(object obj) => obj is nng_sockaddr_ipc other && Equals(other);
        
        public override int GetHashCode() => Value.GetHashCode();
        
        public override string ToString() => Value.ToString();
        
        public static implicit operator nng.nng_sockaddr_path(nng_sockaddr_ipc from) => from.Value;
        
        public static implicit operator nng_sockaddr_ipc(nng.nng_sockaddr_path from) => new nng_sockaddr_ipc(from);
        
        public static bool operator ==(nng_sockaddr_ipc left, nng_sockaddr_ipc right) => left.Equals(right);
        
        public static bool operator !=(nng_sockaddr_ipc left, nng_sockaddr_ipc right) => !left.Equals(right);
    }
    
    /// <summary>
    /// Scatter/gather I/O.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial struct nng_iov
    {
        public IntPtr iov_buf;
        
        public nng.size_t iov_len;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct size_t : IEquatable<size_t>
    {
        public size_t(IntPtr value) => this.Value = value;
        
        public readonly IntPtr Value;
        
        public bool Equals(size_t other) =>  Value.Equals(other.Value);
        
        public override bool Equals(object obj) => obj is size_t other && Equals(other);
        
        public override int GetHashCode() => Value.GetHashCode();
        
        public override string ToString() => Value.ToString();
        
        public static implicit operator IntPtr(size_t from) => from.Value;
        
        public static implicit operator size_t(IntPtr from) => new size_t(from);
        
        public static bool operator ==(size_t left, size_t right) => left.Equals(right);
        
        public static bool operator !=(size_t left, size_t right) => !left.Equals(right);
    }
    
    /// <summary>
    /// URL support.  We frequently want to process a URL, and these methods
    /// give us a convenient way of doing so.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public partial struct nng_url
    {
        /// <summary>
        /// never NULL
        /// </summary>
        public IntPtr u_rawurl;
        
        /// <summary>
        /// never NULL
        /// </summary>
        public IntPtr u_scheme;
        
        /// <summary>
        /// will be NULL if not specified
        /// </summary>
        public IntPtr u_userinfo;
        
        /// <summary>
        /// including colon and port
        /// </summary>
        public IntPtr u_host;
        
        /// <summary>
        /// name only, will be "" if not specified
        /// </summary>
        public IntPtr u_hostname;
        
        /// <summary>
        /// port, will be "" if not specified
        /// </summary>
        public IntPtr u_port;
        
        /// <summary>
        /// path, will be "" if not specified
        /// </summary>
        public IntPtr u_path;
        
        /// <summary>
        /// without '?', will be NULL if not specified
        /// </summary>
        public IntPtr u_query;
        
        /// <summary>
        /// without '#', will be NULL if not specified
        /// </summary>
        public IntPtr u_fragment;
        
        /// <summary>
        /// includes query and fragment, "" if not specified
        /// </summary>
        public IntPtr u_requri;
    }
    
    /// <summary>
    /// nng_stream operations permit direct access to low level streams,
    /// which can have a variety of uses.  Internally most of the transports
    /// are built on top of these.  Streams are created by other dialers or
    /// listeners.  The API for creating dialers and listeners varies.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_stream : IEquatable<nng_stream>
    {
        private readonly IntPtr _handle;
        
        public nng_stream(IntPtr handle) => _handle = handle;
        
        public IntPtr Handle => _handle;
        
        public bool Equals(nng_stream other) => _handle.Equals(other._handle);
        
        public override bool Equals(object obj) => obj is nng_stream other && Equals(other);
        
        public override int GetHashCode() => _handle.GetHashCode();
        
        public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
        
        public static bool operator ==(nng_stream left, nng_stream right) => left.Equals(right);
        
        public static bool operator !=(nng_stream left, nng_stream right) => !left.Equals(right);
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_stream_dialer : IEquatable<nng_stream_dialer>
    {
        private readonly IntPtr _handle;
        
        public nng_stream_dialer(IntPtr handle) => _handle = handle;
        
        public IntPtr Handle => _handle;
        
        public bool Equals(nng_stream_dialer other) => _handle.Equals(other._handle);
        
        public override bool Equals(object obj) => obj is nng_stream_dialer other && Equals(other);
        
        public override int GetHashCode() => _handle.GetHashCode();
        
        public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
        
        public static bool operator ==(nng_stream_dialer left, nng_stream_dialer right) => left.Equals(right);
        
        public static bool operator !=(nng_stream_dialer left, nng_stream_dialer right) => !left.Equals(right);
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_stream_listener : IEquatable<nng_stream_listener>
    {
        private readonly IntPtr _handle;
        
        public nng_stream_listener(IntPtr handle) => _handle = handle;
        
        public IntPtr Handle => _handle;
        
        public bool Equals(nng_stream_listener other) => _handle.Equals(other._handle);
        
        public override bool Equals(object obj) => obj is nng_stream_listener other && Equals(other);
        
        public override int GetHashCode() => _handle.GetHashCode();
        
        public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
        
        public static bool operator ==(nng_stream_listener left, nng_stream_listener right) => left.Equals(right);
        
        public static bool operator !=(nng_stream_listener left, nng_stream_listener right) => !left.Equals(right);
    }
    
    /// <summary>
    /// Identifiers are wrapped in a structure to improve compiler validation
    /// of incorrect passing.  This gives us strong type checking.  Modern
    /// compilers compile passing these by value to identical code as passing
    /// the integer type (at least with optimization applied).  Please do not
    /// access the ID member directly.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_ctx : IEquatable<nng_ctx>
    {
        public nng_ctx(nng.nng_ctx_s value) => this.Value = value;
        
        public readonly nng.nng_ctx_s Value;
        
        public bool Equals(nng_ctx other) =>  Value.Equals(other.Value);
        
        public override bool Equals(object obj) => obj is nng_ctx other && Equals(other);
        
        public override int GetHashCode() => Value.GetHashCode();
        
        public override string ToString() => Value.ToString();
        
        public static implicit operator nng.nng_ctx_s(nng_ctx from) => from.Value;
        
        public static implicit operator nng_ctx(nng.nng_ctx_s from) => new nng_ctx(from);
        
        public static bool operator ==(nng_ctx left, nng_ctx right) => left.Equals(right);
        
        public static bool operator !=(nng_ctx left, nng_ctx right) => !left.Equals(right);
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_dialer : IEquatable<nng_dialer>
    {
        public nng_dialer(nng.nng_dialer_s value) => this.Value = value;
        
        public readonly nng.nng_dialer_s Value;
        
        public bool Equals(nng_dialer other) =>  Value.Equals(other.Value);
        
        public override bool Equals(object obj) => obj is nng_dialer other && Equals(other);
        
        public override int GetHashCode() => Value.GetHashCode();
        
        public override string ToString() => Value.ToString();
        
        public static implicit operator nng.nng_dialer_s(nng_dialer from) => from.Value;
        
        public static implicit operator nng_dialer(nng.nng_dialer_s from) => new nng_dialer(from);
        
        public static bool operator ==(nng_dialer left, nng_dialer right) => left.Equals(right);
        
        public static bool operator !=(nng_dialer left, nng_dialer right) => !left.Equals(right);
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_listener : IEquatable<nng_listener>
    {
        public nng_listener(nng.nng_listener_s value) => this.Value = value;
        
        public readonly nng.nng_listener_s Value;
        
        public bool Equals(nng_listener other) =>  Value.Equals(other.Value);
        
        public override bool Equals(object obj) => obj is nng_listener other && Equals(other);
        
        public override int GetHashCode() => Value.GetHashCode();
        
        public override string ToString() => Value.ToString();
        
        public static implicit operator nng.nng_listener_s(nng_listener from) => from.Value;
        
        public static implicit operator nng_listener(nng.nng_listener_s from) => new nng_listener(from);
        
        public static bool operator ==(nng_listener left, nng_listener right) => left.Equals(right);
        
        public static bool operator !=(nng_listener left, nng_listener right) => !left.Equals(right);
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_pipe : IEquatable<nng_pipe>
    {
        public nng_pipe(nng.nng_pipe_s value) => this.Value = value;
        
        public readonly nng.nng_pipe_s Value;
        
        public bool Equals(nng_pipe other) =>  Value.Equals(other.Value);
        
        public override bool Equals(object obj) => obj is nng_pipe other && Equals(other);
        
        public override int GetHashCode() => Value.GetHashCode();
        
        public override string ToString() => Value.ToString();
        
        public static implicit operator nng.nng_pipe_s(nng_pipe from) => from.Value;
        
        public static implicit operator nng_pipe(nng.nng_pipe_s from) => new nng_pipe(from);
        
        public static bool operator ==(nng_pipe left, nng_pipe right) => left.Equals(right);
        
        public static bool operator !=(nng_pipe left, nng_pipe right) => !left.Equals(right);
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_socket : IEquatable<nng_socket>
    {
        public nng_socket(nng.nng_socket_s value) => this.Value = value;
        
        public readonly nng.nng_socket_s Value;
        
        public bool Equals(nng_socket other) =>  Value.Equals(other.Value);
        
        public override bool Equals(object obj) => obj is nng_socket other && Equals(other);
        
        public override int GetHashCode() => Value.GetHashCode();
        
        public override string ToString() => Value.ToString();
        
        public static implicit operator nng.nng_socket_s(nng_socket from) => from.Value;
        
        public static implicit operator nng_socket(nng.nng_socket_s from) => new nng_socket(from);
        
        public static bool operator ==(nng_socket left, nng_socket right) => left.Equals(right);
        
        public static bool operator !=(nng_socket left, nng_socket right) => !left.Equals(right);
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
    public readonly partial struct nng_duration : IEquatable<nng_duration>
    {
        public nng_duration(int value) => this.Value = value;
        
        public readonly int Value;
        
        public bool Equals(nng_duration other) =>  Value.Equals(other.Value);
        
        public override bool Equals(object obj) => obj is nng_duration other && Equals(other);
        
        public override int GetHashCode() => Value.GetHashCode();
        
        public override string ToString() => Value.ToString();
        
        public static implicit operator int(nng_duration from) => from.Value;
        
        public static implicit operator nng_duration(int from) => new nng_duration(from);
        
        public static bool operator ==(nng_duration left, nng_duration right) => left.Equals(right);
        
        public static bool operator !=(nng_duration left, nng_duration right) => !left.Equals(right);
    }
    
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void nng_pipe_cb(nng.nng_pipe arg0, nng.nng_pipe_ev arg1, IntPtr arg2);
    
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void nng_aio_cancelfn(nng.nng_aio arg0, IntPtr arg1, int arg2);
    
    public const int NNG_DURATION_INFINITE = (-1);
    
    public const int NNG_DURATION_DEFAULT = (-2);
    
    public const int NNG_DURATION_ZERO = (0);
    
    /// <summary>
    /// Recv to allocate receive buffer
    /// </summary>
    public const int NNG_FLAG_ALLOC = 1;
    
    /// <summary>
    /// Non-blocking operations
    /// </summary>
    public const int NNG_FLAG_NONBLOCK = 2;
    
    /// <summary>
    /// nng_fini is used to terminate the library, freeing certain global resources.
    /// This should only be called during atexit() or just before dlclose().
    /// THIS FUNCTION MUST NOT BE CALLED CONCURRENTLY WITH ANY OTHER FUNCTION
    /// IN THIS LIBRARY; IT IS NOT REENTRANT OR THREADSAFE.
    /// </summary>
    /// <remarks>
    /// For most cases, this call is unnecessary, but it is provided to assist
    /// when debugging with memory checkers (e.g. valgrind).  Calling this
    /// function prevents global library resources from being reported incorrectly
    /// as memory leaks.  In those cases, we recommend doing this with atexit().
    /// </remarks>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_fini();
    
    /// <summary>
    /// nng_close closes the socket, terminating all activity and
    /// closing any underlying connections and releasing any associated
    /// resources.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_close(nng.nng_socket arg0);
    
    /// <summary>
    /// nng_socket_id returns the positive socket id for the socket, or -1
    /// if the socket is not valid.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_id(nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_set(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_set_bool(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.U1)] bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_set_int(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_set_size(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_set_uint64(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_set_string(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_set_ptr(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_set_ms(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_set_addr(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, in nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_get(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, ref nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_get_bool(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_get_int(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_get_size(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_get_uint64(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_get_string(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_get_ptr(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_get_ms(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_socket_get_addr(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_sockaddr arg2);
    
    /// <summary>
    /// nng_pipe_notify registers a callback to be executed when the
    /// given event is triggered.  To watch for different events, register
    /// multiple times.  Each event can have at most one callback registered.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_notify(nng.nng_socket arg0, nng.nng_pipe_ev arg1, nng.nng_pipe_cb arg2, IntPtr arg3);
    
    /// <summary>
    /// nng_listen creates a listening endpoint with no special options,
    /// and starts it listening.  It is functionally equivalent to the legacy
    /// nn_bind(). The underlying endpoint is returned back to the caller in the
    /// endpoint pointer, if it is not NULL.  The flags are ignored at present.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listen(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_listener arg2, int arg3);
    
    /// <summary>
    /// nng_dial creates a dialing endpoint, with no special options, and
    /// starts it dialing.  Dialers have at most one active connection at a time
    /// This is similar to the legacy nn_connect().  The underlying endpoint
    /// is returned back to the caller in the endpoint pointer, if it is not NULL.
    /// The flags may be NNG_FLAG_NONBLOCK to indicate that the first attempt to
    /// dial will be made in the background, returning control to the caller
    /// immediately.  In this case, if the connection fails, the function will
    /// keep retrying in the background.  (If the connection is dropped in either
    /// case, it will still be reconnected in the background -- only the initial
    /// connection attempt is normally synchronous.)
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dial(nng.nng_socket arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_dialer arg2, int arg3);
    
    /// <summary>
    /// nng_dialer_create creates a new dialer, that is not yet started.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_create(ref nng.nng_dialer arg0, nng.nng_socket arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg2);
    
    /// <summary>
    /// nng_listener_create creates a new listener, that is not yet started.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_create(ref nng.nng_listener arg0, nng.nng_socket arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg2);
    
    /// <summary>
    /// nng_dialer_start starts the endpoint dialing.  This is only possible if
    /// the dialer is not already dialing.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_start(nng.nng_dialer arg0, int arg1);
    
    /// <summary>
    /// nng_listener_start starts the endpoint listening.  This is only possible if
    /// the listener is not already listening.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_start(nng.nng_listener arg0, int arg1);
    
    /// <summary>
    /// nng_dialer_close closes the dialer, shutting down all underlying
    /// connections and releasing all associated resources.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_close(nng.nng_dialer arg0);
    
    /// <summary>
    /// nng_listener_close closes the listener, shutting down all underlying
    /// connections and releasing all associated resources.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_close(nng.nng_listener arg0);
    
    /// <summary>
    /// nng_dialer_id returns the positive dialer ID, or -1 if the dialer is
    /// invalid.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_id(nng.nng_dialer arg0);
    
    /// <summary>
    /// nng_listener_id returns the positive listener ID, or -1 if the listener is
    /// invalid.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_id(nng.nng_listener arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_set(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_set_bool(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.U1)] bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_set_int(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_set_size(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_set_uint64(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_set_string(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_set_ptr(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_set_ms(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_set_addr(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, in nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_get(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, ref nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_get_bool(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_get_int(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_get_size(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_get_uint64(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_get_string(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_get_ptr(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_get_ms(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_dialer_get_addr(nng.nng_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_set(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_set_bool(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.U1)] bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_set_int(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_set_size(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_set_uint64(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_set_string(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_set_ptr(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_set_ms(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_set_addr(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, in nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_get(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, ref nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_get_bool(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_get_int(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_get_size(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_get_uint64(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_get_string(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_get_ptr(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_get_ms(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_listener_get_addr(nng.nng_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_sockaddr arg2);
    
    /// <summary>
    /// nng_strerror returns a human readable string associated with the error
    /// code supplied.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ReturnUtf8StringMarshaller))]
    public static extern string nng_strerror(int arg0);
    
    /// <summary>
    /// nng_send sends (or arranges to send) the data on the socket.  Note that
    /// this function may (will!) return before any receiver has actually
    /// received the data.  The return value will be zero to indicate that the
    /// socket has accepted the entire data for send, or an errno to indicate
    /// failure.  The flags may include NNG_FLAG_NONBLOCK or NNG_FLAG_ALLOC.
    /// If the flag includes NNG_FLAG_ALLOC, then the function will call
    /// nng_free() on the supplied pointer 
    /// &amp;
    /// size on success. (If the call
    /// fails then the memory is not freed.)
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_send(nng.nng_socket arg0, IntPtr arg1, nng.size_t arg2, int arg3);
    
    /// <summary>
    /// nng_recv receives message data into the socket, up to the supplied size.
    /// The actual size of the message data will be written to the value pointed
    /// to by size.  The flags may include NNG_FLAG_NONBLOCK and NNG_FLAG_ALLOC.
    /// If NNG_FLAG_ALLOC is supplied then the library will allocate memory for
    /// the caller.  In that case the pointer to the allocated will be stored
    /// instead of the data itself.  The caller is responsible for freeing the
    /// associated memory with nng_free().
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_recv(nng.nng_socket arg0, IntPtr arg1, ref nng.size_t arg2, int arg3);
    
    /// <summary>
    /// nng_sendmsg is like nng_send, but offers up a message structure, which
    /// gives the ability to provide more control over the message, including
    /// providing backtrace information.  It also can take a message that was
    /// obtain via nn_recvmsg, allowing for zero copy forwarding.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_sendmsg(nng.nng_socket arg0, nng.nng_msg arg1, int arg2);
    
    /// <summary>
    /// nng_recvmsg is like nng_recv, but is used to obtain a message structure
    /// as well as the data buffer.  This can be used to obtain more information
    /// about where the message came from, access raw headers, etc.  It also
    /// can be passed off directly to nng_sendmsg.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_recvmsg(nng.nng_socket arg0, out nng.nng_msg arg1, int arg2);
    
    /// <summary>
    /// nng_send_aio sends data on the socket asynchronously.  As with nng_send,
    /// the completion may be executed before the data has actually been delivered,
    /// but only when it is accepted for delivery.  The supplied AIO must have
    /// been initialized, and have an associated message.  The message will be
    /// "owned" by the socket if the operation completes successfully.  Otherwise
    /// the caller is responsible for freeing it.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_send_aio(nng.nng_socket arg0, nng.nng_aio arg1);
    
    /// <summary>
    /// nng_recv_aio receives data on the socket asynchronously.  On a successful
    /// result, the AIO will have an associated message, that can be obtained
    /// with nng_aio_get_msg().  The caller takes ownership of the message at
    /// this point.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_recv_aio(nng.nng_socket arg0, nng.nng_aio arg1);
    
    /// <summary>
    /// nng_ctx_open creates a context.  This returns NNG_ENOTSUP if the
    /// protocol implementation does not support separate contexts.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_open(ref nng.nng_ctx arg0, nng.nng_socket arg1);
    
    /// <summary>
    /// nng_ctx_close closes the context.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_close(nng.nng_ctx arg0);
    
    /// <summary>
    /// nng_ctx_id returns the numeric id for the context; this will be
    /// a positive value for a valid context, or 
    /// &lt;
    /// 0 for an invalid context.
    /// A valid context is not necessarily an *open* context.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_id(nng.nng_ctx arg0);
    
    /// <summary>
    /// nng_ctx_recv receives asynchronously.  It works like nng_recv_aio, but
    /// uses a local context instead of the socket global context.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_ctx_recv(nng.nng_ctx arg0, nng.nng_aio arg1);
    
    /// <summary>
    /// nng_ctx_send sends asynchronously. It works like nng_send_aio, but
    /// uses a local context instead of the socket global context.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_ctx_send(nng.nng_ctx arg0, nng.nng_aio arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_get(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, ref nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_get_bool(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_get_int(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_get_size(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_get_uint64(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_get_string(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_get_ptr(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_get_ms(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_get_addr(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_set(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_set_bool(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.U1)] bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_set_int(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_set_size(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_set_uint64(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_set_string(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_set_ptr(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_set_ms(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_ctx_set_addr(nng.nng_ctx arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, in nng.nng_sockaddr arg2);
    
    /// <summary>
    /// nng_alloc is used to allocate memory.  It's intended purpose is for
    /// allocating memory suitable for message buffers with nng_send().
    /// Applications that need memory for other purposes should use their platform
    /// specific API.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr nng_alloc(nng.size_t arg0);
    
    /// <summary>
    /// nng_free is used to free memory allocated with nng_alloc, which includes
    /// memory allocated by nng_recv() when the NNG_FLAG_ALLOC message is supplied.
    /// As the application is required to keep track of the size of memory, this
    /// is probably less convenient for general uses than the C library malloc and
    /// calloc.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_free(IntPtr arg0, nng.size_t arg1);
    
    /// <summary>
    /// nng_strdup duplicates the source string, using nng_alloc. The result
    /// should be freed with nng_strfree (or nng_free(strlen(s)+1)).
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr nng_strdup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg0);
    
    /// <summary>
    /// nng_strfree is equivalent to nng_free(strlen(s)+1).
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_strfree(IntPtr arg0);
    
    /// <summary>
    /// nng_aio_free frees the AIO and any associated resources.
    /// It *must not* be in use at the time it is freed.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_free(nng.nng_aio arg0);
    
    /// <summary>
    /// nng_aio_reap is like nng_aio_free, but calls it from a background
    /// reaper thread.  This can be useful to free aio objects from aio
    /// callbacks (e.g. when the result of the callback is to discard
    /// the object in question.)  The aio object must be in further use
    /// when this is called.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_reap(nng.nng_aio arg0);
    
    /// <summary>
    /// nng_aio_stop stops any outstanding operation, and waits for the
    /// AIO to be free, including for the callback to have completed
    /// execution.  Therefore the caller must NOT hold any locks that
    /// are acquired in the callback, or deadlock will occur.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_stop(nng.nng_aio arg0);
    
    /// <summary>
    /// nng_aio_result returns the status/result of the operation. This
    /// will be zero on successful completion, or an nng error code on
    /// failure.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_aio_result(nng.nng_aio arg0);
    
    /// <summary>
    /// nng_aio_count returns the number of bytes transferred for certain
    /// I/O operations.  This is meaningless for other operations (e.g.
    /// DNS lookups or TCP connection setup).
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.size_t nng_aio_count(nng.nng_aio arg0);
    
    /// <summary>
    /// nng_aio_cancel attempts to cancel any in-progress I/O operation.
    /// The AIO callback will still be executed, but if the cancellation is
    /// successful then the status will be NNG_ECANCELED.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_cancel(nng.nng_aio arg0);
    
    /// <summary>
    /// nng_aio_abort is like nng_aio_cancel, but allows for a different
    /// error result to be returned.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_abort(nng.nng_aio arg0, int arg1);
    
    /// <summary>
    /// nng_aio_wait waits synchronously for any pending operation to complete.
    /// It also waits for the callback to have completed execution.  Therefore,
    /// the caller of this function must not hold any locks acquired by the
    /// callback or deadlock may occur.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_wait(nng.nng_aio arg0);
    
    /// <summary>
    /// nng_aio_set_msg sets the message structure to use for asynchronous
    /// message send operations.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_set_msg(nng.nng_aio arg0, nng.nng_msg arg1);
    
    /// <summary>
    /// nng_aio_get_msg returns the message structure associated with a completed
    /// receive operation.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_msg nng_aio_get_msg(nng.nng_aio arg0);
    
    /// <summary>
    /// nng_aio_set_input sets an input parameter at the given index.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_aio_set_input(nng.nng_aio arg0, uint arg1, IntPtr arg2);
    
    /// <summary>
    /// nng_aio_get_input retrieves the input parameter at the given index.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr nng_aio_get_input(nng.nng_aio arg0, uint arg1);
    
    /// <summary>
    /// nng_aio_set_output sets an output result at the given index.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_aio_set_output(nng.nng_aio arg0, uint arg1, IntPtr arg2);
    
    /// <summary>
    /// nng_aio_get_output retrieves the output result at the given index.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr nng_aio_get_output(nng.nng_aio arg0, uint arg1);
    
    /// <summary>
    /// nng_aio_set_timeout sets a timeout on the AIO.  This should be called for
    /// operations that should time out after a period.  The timeout should be
    /// either a positive number of milliseconds, or NNG_DURATION_INFINITE to
    /// indicate that the operation has no timeout.  A poll may be done by
    /// specifying NNG_DURATION_ZERO.  The value NNG_DURATION_DEFAULT indicates
    /// that any socket specific timeout should be used.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_set_timeout(nng.nng_aio arg0, nng.nng_duration arg1);
    
    /// <summary>
    /// nng_aio_set_iov sets a scatter/gather vector on the aio.  The iov array
    /// itself is copied. Data members (the memory regions referenced) *may* be
    /// copied as well, depending on the operation.  This operation is guaranteed
    /// to succeed if n 
    /// &lt;
    /// = 4, otherwise it may fail due to NNG_ENOMEM.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_aio_set_iov(nng.nng_aio arg0, uint arg1, in nng.nng_iov arg2);
    
    /// <summary>
    /// nng_aio_begin is called by the provider to mark the operation as
    /// beginning.  If it returns false, then the provider must take no
    /// further action on the aio.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    [return:MarshalAs(UnmanagedType.U1)]
    public static extern bool nng_aio_begin(nng.nng_aio arg0);
    
    /// <summary>
    /// nng_aio_finish is used to "finish" an asynchronous operation.
    /// It should only be called by "providers" (such as HTTP server API users).
    /// The argument is the value that nng_aio_result() should return.
    /// IMPORTANT: Callers must ensure that this is called EXACTLY ONCE on any
    /// given aio.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_finish(nng.nng_aio arg0, int arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_aio_defer(nng.nng_aio arg0, nng.nng_aio_cancelfn arg1, IntPtr arg2);
    
    /// <summary>
    /// nng_aio_sleep does a "sleeping" operation, basically does nothing
    /// but wait for the specified number of milliseconds to expire, then
    /// calls the callback.  This returns 0, rather than NNG_ETIMEDOUT.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_sleep_aio(nng.nng_duration arg0, nng.nng_aio arg1);
    
    /// <summary>
    /// Message API.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_alloc(out nng.nng_msg arg0, nng.size_t arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_msg_free(nng.nng_msg arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_realloc(nng.nng_msg arg0, nng.size_t arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_reserve(nng.nng_msg arg0, nng.size_t arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.size_t nng_msg_capacity(nng.nng_msg arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr nng_msg_header(nng.nng_msg arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.size_t nng_msg_header_len(nng.nng_msg arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr nng_msg_body(nng.nng_msg arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.size_t nng_msg_len(nng.nng_msg arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_append(nng.nng_msg arg0, IntPtr arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_insert(nng.nng_msg arg0, IntPtr arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_trim(nng.nng_msg arg0, nng.size_t arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_chop(nng.nng_msg arg0, nng.size_t arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_append(nng.nng_msg arg0, IntPtr arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_insert(nng.nng_msg arg0, IntPtr arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_trim(nng.nng_msg arg0, nng.size_t arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_chop(nng.nng_msg arg0, nng.size_t arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_append_u16(nng.nng_msg arg0, ushort arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_append_u32(nng.nng_msg arg0, uint arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_append_u64(nng.nng_msg arg0, ulong arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_insert_u16(nng.nng_msg arg0, ushort arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_insert_u32(nng.nng_msg arg0, uint arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_insert_u64(nng.nng_msg arg0, ulong arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_chop_u16(nng.nng_msg arg0, ref ushort arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_chop_u32(nng.nng_msg arg0, ref uint arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_chop_u64(nng.nng_msg arg0, ref ulong arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_trim_u16(nng.nng_msg arg0, ref ushort arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_trim_u32(nng.nng_msg arg0, ref uint arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_header_trim_u64(nng.nng_msg arg0, ref ulong arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_append_u16(nng.nng_msg arg0, ushort arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_append_u32(nng.nng_msg arg0, uint arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_append_u64(nng.nng_msg arg0, ulong arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_insert_u16(nng.nng_msg arg0, ushort arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_insert_u32(nng.nng_msg arg0, uint arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_insert_u64(nng.nng_msg arg0, ulong arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_chop_u16(nng.nng_msg arg0, ref ushort arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_chop_u32(nng.nng_msg arg0, ref uint arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_chop_u64(nng.nng_msg arg0, ref ulong arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_trim_u16(nng.nng_msg arg0, ref ushort arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_trim_u32(nng.nng_msg arg0, ref uint arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_trim_u64(nng.nng_msg arg0, ref ulong arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_msg_dup(out nng.nng_msg arg0, nng.nng_msg arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_msg_clear(nng.nng_msg arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_msg_header_clear(nng.nng_msg arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_msg_set_pipe(nng.nng_msg arg0, nng.nng_pipe arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_pipe nng_msg_get_pipe(nng.nng_msg arg0);
    
    /// <summary>
    /// Pipe API. Generally pipes are only "observable" to applications, but
    /// we do permit an application to close a pipe. This can be useful, for
    /// example during a connection notification, to disconnect a pipe that
    /// is associated with an invalid or untrusted remote peer.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_get(nng.nng_pipe arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, ref nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_get_bool(nng.nng_pipe arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_get_int(nng.nng_pipe arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_get_ms(nng.nng_pipe arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_get_size(nng.nng_pipe arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_get_uint64(nng.nng_pipe arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_get_string(nng.nng_pipe arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_get_ptr(nng.nng_pipe arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_get_addr(nng.nng_pipe arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_close(nng.nng_pipe arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pipe_id(nng.nng_pipe arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_socket nng_pipe_socket(nng.nng_pipe arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_dialer nng_pipe_dialer(nng.nng_pipe arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_listener nng_pipe_listener(nng.nng_pipe arg0);
    
    /// <summary>
    /// nng_stats_get takes a snapshot of the entire set of statistics.
    /// While the operation can be somewhat expensive (allocations), it
    /// is done in a way that minimizes impact to running operations.
    /// Note that the statistics are provided as a tree, with parents
    /// used for grouping, and with child statistics underneath.  The
    /// top stat returned will be of type NNG_STAT_SCOPE with name "".
    /// Applications may choose to consider this root scope as "root", if
    /// the empty string is not suitable.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stats_get(out nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stats_free frees a previous list of snapshots.  This should only
    /// be called on the parent statistic that obtained via nng_stats_get.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stats_free(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stats_dump is a debugging function that dumps the entire set of
    /// statistics to stdout.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stats_dump(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_next finds the next sibling for the current stat.  If there
    /// are no more siblings, it returns NULL.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_stat nng_stat_next(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_child finds the first child of the current stat.  If no children
    /// exist, then NULL is returned.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_stat nng_stat_child(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_name is used to determine the name of the statistic.
    /// This is a human readable name.  Statistic names, as well as the presence
    /// or absence or semantic of any particular statistic are not part of any
    /// stable API, and may be changed without notice in future updates.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ReturnUtf8StringMarshaller))]
    public static extern string nng_stat_name(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_type is used to determine the type of the statistic.
    /// Counters generally increment, and therefore changes in the value over
    /// time are likely more interesting than the actual level.  Level
    /// values reflect some absolute state however, and should be presented to the
    /// user as is.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stat_type(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_find is used to find a specific named statistic within
    /// a statistic tree.  NULL is returned if no such statistic exists.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_stat nng_stat_find(nng.nng_stat arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1);
    
    /// <summary>
    /// nng_stat_find_socket is used to find the stats for the given socket.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_stat nng_stat_find_socket(nng.nng_stat arg0, nng.nng_socket arg1);
    
    /// <summary>
    /// nng_stat_find_dialer is used to find the stats for the given dialer.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_stat nng_stat_find_dialer(nng.nng_stat arg0, nng.nng_dialer arg1);
    
    /// <summary>
    /// nng_stat_find_listener is used to find the stats for the given listener.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern nng.nng_stat nng_stat_find_listener(nng.nng_stat arg0, nng.nng_listener arg1);
    
    /// <summary>
    /// nng_stat_unit provides information about the unit for the statistic,
    /// such as NNG_UNIT_BYTES or NNG_UNIT_BYTES.  If no specific unit is
    /// applicable, such as a relative priority, then NN_UNIT_NONE is returned.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stat_unit(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_value returns returns the actual value of the statistic.
    /// Statistic values reflect their value at the time that the corresponding
    /// snapshot was updated, and are undefined until an update is performed.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong nng_stat_value(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_value returns returns the actual value of the statistic.
    /// Statistic values reflect their value at the time that the corresponding
    /// snapshot was updated, and are undefined until an update is performed.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    [return:MarshalAs(UnmanagedType.U1)]
    public static extern bool nng_stat_bool(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_string returns the string associated with a string statistic,
    /// or NULL if the statistic is not part of the string.  The value returned
    /// is valid until the associated statistic is freed.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ReturnUtf8StringMarshaller))]
    public static extern string nng_stat_string(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_desc returns a human readable description of the statistic.
    /// This may be useful for display in diagnostic interfaces, etc.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ReturnUtf8StringMarshaller))]
    public static extern string nng_stat_desc(nng.nng_stat arg0);
    
    /// <summary>
    /// nng_stat_timestamp returns a timestamp (milliseconds) when the statistic
    /// was captured.  The base offset is the same as used by nng_clock().
    /// We don't use nng_time though, because that's in the supplemental header.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong nng_stat_timestamp(nng.nng_stat arg0);
    
    /// <summary>
    /// Device functionality.  This connects two sockets together in a device,
    /// which means that messages from one side are forwarded to the other.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_device(nng.nng_socket arg0, nng.nng_socket arg1);
    
    /// <summary>
    /// nng_url_parse parses a URL string into a structured form.
    /// Note that the u_port member will be filled out with a numeric
    /// port if one isn't specified and a default port is appropriate for
    /// the scheme.  The URL structure is allocated, along with individual
    /// members.  It can be freed with nng_url_free.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_url_parse(out IntPtr arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1);
    
    /// <summary>
    /// nng_url_free frees a URL structure that was created by nng_url_parse().
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_url_free(ref nng.nng_url arg0);
    
    /// <summary>
    /// nng_url_clone clones a URL structure.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_url_clone(out IntPtr arg0, in nng.nng_url arg1);
    
    /// <summary>
    /// nng_version returns the library version as a human readable string.
    /// </summary>
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    [return:MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ReturnUtf8StringMarshaller))]
    public static extern string nng_version();
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_free(nng.nng_stream arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_close(nng.nng_stream arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_send(nng.nng_stream arg0, nng.nng_aio arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_recv(nng.nng_stream arg0, nng.nng_aio arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_get(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, ref nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_get_bool(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_get_int(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_get_ms(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_get_size(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_get_uint64(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_get_string(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_get_ptr(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_get_addr(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_set(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_set_bool(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.U1)] bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_set_int(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_set_ms(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_set_size(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_set_uint64(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_set_string(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_set_ptr(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_set_addr(nng.nng_stream arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, in nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_alloc(out nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_alloc_url(out nng.nng_stream_dialer arg0, in nng.nng_url arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_dialer_free(nng.nng_stream_dialer arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_dialer_close(nng.nng_stream_dialer arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_dialer_dial(nng.nng_stream_dialer arg0, nng.nng_aio arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_set(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_get(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, ref nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_get_bool(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_get_int(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_get_ms(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_get_size(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_get_uint64(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_get_string(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_get_ptr(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_get_addr(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_set_bool(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.U1)] bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_set_int(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_set_ms(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_set_size(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_set_uint64(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_set_string(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_set_ptr(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_dialer_set_addr(nng.nng_stream_dialer arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, in nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_alloc(out nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_alloc_url(out nng.nng_stream_listener arg0, in nng.nng_url arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_listener_free(nng.nng_stream_listener arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_listener_close(nng.nng_stream_listener arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_listen(nng.nng_stream_listener arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern void nng_stream_listener_accept(nng.nng_stream_listener arg0, nng.nng_aio arg1);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_set(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_get(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2, ref nng.size_t arg3);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_get_bool(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_get_int(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_get_ms(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_get_size(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_get_uint64(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_get_string(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_get_ptr(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, out IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_get_addr(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ref nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_set_bool(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.U1)] bool arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_set_int(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, int arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_set_ms(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.nng_duration arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_set_size(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, nng.size_t arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_set_uint64(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, ulong arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_set_string(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_set_ptr(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, IntPtr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_stream_listener_set_addr(nng.nng_stream_listener arg0, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(FastUtf8StringMarshaller))] string arg1, in nng.nng_sockaddr arg2);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_bus0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_bus0_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pair0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pair0_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pair1_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pair1_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pair1_open_poly(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pull0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pull0_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_push0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_push0_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pub0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_pub0_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_sub0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_sub0_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_rep0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_rep0_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_req0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_req0_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_respondent0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_respondent0_open_raw(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_surveyor0_open(ref nng.nng_socket arg0);
    
    [DllImport(nngDll, CallingConvention = CallingConvention.Cdecl)]
    public static extern int nng_surveyor0_open_raw(ref nng.nng_socket arg0);
}
